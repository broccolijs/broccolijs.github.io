<!DOCTYPE html>
<html lang="en">

<head>
    <title>What is Broccoli.js? | broccoli.build</title>
    <meta name="description" content="Broccoli.js - The asset pipeline for ambitious web applications">
    <link media="all" rel="stylesheet" href="/assets/site-cfe318f67f5d82208f55f7b36bd7abd5.css" />

    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicon/apple-touch-icon-46d49475781a4e8ffacd9d757b2b2af3.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon/favicon-32x32-73910b61c8ca8f3b038c58161a86322d.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon/favicon-16x16-5a05f8998791ee6ee2471d3871e8de03.png">
    <link rel="manifest" href="/assets/favicon/site-b9aa277fcfc34c31db6c7a7ea3469b8c.webmanifest">
    <link rel="mask-icon" href="/assets/favicon/safari-pinned-tab-8c270b1f8fb035bee9be6c5c779a557a.svg" color="#628336">
    <meta name="msapplication-TileColor" content="#00aba9">
    <meta name="theme-color" content="#ffffff">

    <meta property="og:title" content="What is Broccoli.js? | broccoli.build" />
    <meta property="og:description" content="Broccoli.js - The asset pipeline for ambitious web applications" />
    <meta property="og:type" content="article" />
    <meta property="og:article:published_time" content="2019-12-16T18:12:70+00:00" />
    <meta property="og:url" content="https://broccoli.build/about.html" />
    <meta property="og:image" content="https://broccoli.build/assets/logo/logo-large-4b34a6c5a21fbbd16639b21ec2e78902.png" />
</head>


<body>
    <nav>
    <ul>
        <li><a href="/" title="Home">Home</a></li>
        <li><a href="/about.html" title="About">About</a></li>
        <li><a href="/getting-started.html" title="Getting Started">Getting Started</a></li>
        <li><a href="/plugins.html" title="Plugins">Plugins</a></li>
    </ul>
</nav>

    <section class="content">
        <h1 class="heading">What is Broccoli.js?</h1>
        <div><p>Broccoli is a JavaScript build tool. A build tool is a piece of software that is responsible for assembling your
applications assets (JavaScript, CSS, images, etc) into some distributable form, usually to run in a browser.
All configuration is done in JavaScript (no confusing/messy config files) via a modular plugin architecture.</p>
<nav class="table-of-contents"><ol><li><a href="#what-is-a-build-tool%3F">What is a build tool? </a></li><li><a href="#thinking-in-broccoli">Thinking in Broccoli </a><ol><li><a href="#directories">Directories </a></li><li><a href="#plugins">Plugins </a></li><li><a href="#trees">Trees </a></li></ol></li><li><a href="#building">Building </a></li><li><a href="#serving">Serving </a></li></ol></nav><h2 id="what-is-a-build-tool%3F">What is a build tool? <a class="header-anchor" href="#what-is-a-build-tool%3F">⚭</a></h2>
<p>A build tool’s job is to take input files (your JavaScript, CSS, HTML, etc), to process them and output the result
of those transformations, usually into some distributable form. Typically this will involve things like JavaScript
transformations to allow you to write newer syntax that will work in a browser, to use a CSS pre-processor like
Sass for your CSS, etc.</p>
<p>Broccoli.js is different from other build tools. You may be used to tools like <a href="https://gruntjs.com/">Grunt</a> (a
task runner), <a href="https://gulpjs.com/">Gulp</a> (streams and pipes) or <a href="https://webpack.js.org/">Webpack</a> (a module
bundler), these all aim to solve different problems than what Broccoli was built for.</p>
<p>Broccoli provides a modular plugin API to leverage other Node tools. Tools like <a href="https://babeljs.io/">Babel</a>,
<a href="https://rollupjs.org/">Rollup</a>, <a href="https://github.com/sass/node-sass">Node-Sass</a>,
<a href="https://webpack.js.org/">Webpack</a>, <a href="http://browserify.org/">Browserify</a>, and many more can easily be used with
Broccoli. These tools perform the actual work by transforming files, Broccoli merely connects inputs to outputs.</p>
<h2 id="thinking-in-broccoli">Thinking in Broccoli <a class="header-anchor" href="#thinking-in-broccoli">⚭</a></h2>
<p>There are 3 main concepts to get your head around when using Broccoli:</p>
<ul>
<li><a href="#directories">Directories</a></li>
<li><a href="#plugins">Plugins</a></li>
<li><a href="#trees">Trees</a></li>
</ul>
<h3 id="directories">Directories <a class="header-anchor" href="#directories">⚭</a></h3>
<p>Using the above tools in a standalone fashion is relatively straight forward, they read input files, and write
to output files. The difficulty comes when connecting different tools together as you need to manage all the
interim state yourself. The only common interface between them is the file system.</p>
<p>Say we want to concatenate our JavaScript files, minify them, and copy the results to our build directory:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>;
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>;
<span class="hljs-keyword">import</span> minify <span class="hljs-keyword">from</span> <span class="hljs-string">'minify'</span>;
<span class="hljs-keyword">import</span> readDir <span class="hljs-keyword">from</span> <span class="hljs-string">'./readDir'</span>;
<span class="hljs-keyword">import</span> readFiles <span class="hljs-keyword">from</span> <span class="hljs-string">'./readFiles'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">concatFiles</span>(<span class="hljs-params">sourceDir, outputFile</span>) </span>{
    <span class="hljs-keyword">const</span> output = readDir(sourceDir).reduce(<span class="hljs-function">(<span class="hljs-params">output, file</span>) =&gt;</span> output += <span class="hljs-string">`;<span class="hljs-subst">${file.content}</span>`</span>, <span class="hljs-string">''</span>);
    fs.writeFileSync(outputFile, output)
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">minifyFiles</span>(<span class="hljs-params">sourceFiles, outputDir</span>) </span>{
    <span class="hljs-keyword">return</span> readFiles(sourceFiles).map(<span class="hljs-function"><span class="hljs-params">file</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> minified = minify(file.path);
        <span class="hljs-keyword">const</span> outputFile = <span class="hljs-string">`<span class="hljs-subst">${outputDir}</span>/<span class="hljs-subst">${file.name}</span>.min.<span class="hljs-subst">${file.extension}</span>`</span>;
        fs.writeFileSync(outputFile, minified)
        <span class="hljs-keyword">return</span> outputFile;
    })
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copyFiles</span>(<span class="hljs-params">sourceFiles, outputDir</span>) </span>{
    sourceFiles.forEach(<span class="hljs-function"><span class="hljs-params">filePath</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> file = path.basename(filePath);
        fs.createReadStream(path).pipe(fs.createWriteStream(<span class="hljs-string">`<span class="hljs-subst">${outputDir}</span>/<span class="hljs-subst">${file}</span>`</span>));
    });
}

<span class="hljs-keyword">const</span> concatted = concatFiles(<span class="hljs-string">'app'</span>, <span class="hljs-string">'/tmp/concat-files'</span>)
<span class="hljs-keyword">const</span> minified = minifyFiles(concatted, <span class="hljs-string">'/tmp/minified-files'</span>)
copyFiles(minified, <span class="hljs-string">'./build'</span>);
</code></pre>
<p>The above is all well and good, but notice how we have to handle the state between each operation. Now imagine how
this scales as our build pipeline grows, adding in Sass compilation, JavaScript transpilation (Babel),
fingerprinting, etc. That’s lots of temp directories and file state that you have to handle.</p>
<p>Broccoli works by managing a set of directories, connected together by plugins, which describe how files
are moved or transformed at each step of the build process. Broccoli ensures plugins are called in the prescribed
order, and writes the result to a <code>target</code> directory. Each plugin is responsible for processing files passed to
it in input directories, and writing files to its output directory. This allows you to focus on the
transformations and not how files are passed between each plugin.</p>
<p>For example:</p>
<pre><code class="hljs language-sh">app                                                       [target]
 ├─ src                                                    │
 │   ├─ index.js   --&gt; ConcatPlugin() ┐                    │
 │   └─ other.js                      ├─ MergePlugin() --&gt; ├─ prod.js
 └─ styles                            │                    └─ site.css
     ├─ site.scss  --&gt; SassPlugin() ──┘
     └─ layout.scss
</code></pre>
<p>Broccoli itself doesn’t really care about files, it simply takes source directories and passes them as inputs to
plugins, creates an output directory for the plugin to write to, and passes that output directory as an input
to the next plugin.</p>
<p>Broccoli is configured with a file in the root of your project called <code>Brocfile.js</code>. This file defines the build
pipeline for your application, and is written in plain old JavaScript. The order in which operations happen is
determined by this build file. All that is required is that <code>export default</code> returns a function that returns a
plugin/string.</p>
<p>You can think of broccoli-plugins much like a simple programming language, where the output of a function can be
passed as the input(s) to another function.</p>
<p>E.g.:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> options =&gt; {
    <span class="hljs-keyword">let</span> js = babel(<span class="hljs-string">'src'</span>);
    js = uglify(js);

    <span class="hljs-keyword">let</span> css = sass(<span class="hljs-string">'src/styles'</span>, <span class="hljs-string">'site.scss'</span>);
    css = autoprefixer(css);

    <span class="hljs-keyword">return</span> merge([js, css]);
};
</code></pre>
<p>This could also be expressed as:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> options =&gt; {
     <span class="hljs-keyword">return</span> merge([
        uglify(
            babel(<span class="hljs-string">'src'</span>)
        ),
        autoprefixer(
            sass(<span class="hljs-string">'src/styles'</span>, <span class="hljs-string">'site.scss'</span>)
        )
    ])
};
</code></pre>
<p>In the above, a <code>src</code> directory is passed to the <code>babel()</code> plugin (which will convert our new ES6 syntax into
ES5 that runs in the browser), the output of that is passed to the <code>uglify()</code> plugin which will minify our JS
into a smaller format. The output of <code>uglify()</code> will in turn be passed as 1 input to <code>merge()</code>.</p>
<p>Additionally, a <code>src/styles</code> directory and the input file <code>site.scss</code> is passed to <code>sass()</code> which will convert your
<code>.scss</code> files into <code>.css</code> files, its output (your css) is passed as an input to <code>autoprefixer()</code> which will add
vendor  prefixes (like <code>-ms</code> or <code>-webkit</code>) to attributes, which is then in turn passed into the <code>merge()</code> plugin.</p>
<p>The <code>merge()</code> plugin will copy the contents of each of its inputs into its output directory. Thus, it merges our
uglified JavaScript and out vendor prefixed css. This then becomes our final output and is what is written to
our target (destination) directory.</p>
<p>Finally, the <code>export default () =&gt;</code> line exports a function that Broccoli will invoke with an <code>options</code> object,
that contains an <code>env</code> property to indicate the environment. This is set from the <code>--environment</code> CLI argument and
defaults to <code>development</code>.</p>
<p>This should all be fairly familiar to you if you’ve ever written JavaScript (or any programming language for that
matter) before; it’s just inputs and output.</p>
<p>Note: <a href="https://nodejs.org/api/esm.html">ES Modules</a> syntax is supported by Broccoli since version 2.1.0. Prior
to this, standard CommonJs syntax with <code>require</code> and <code>module.exports</code> should be used.</p>
<h3 id="plugins">Plugins <a class="header-anchor" href="#plugins">⚭</a></h3>
<p>Plugins are what a build pipeline developer will interact with most. Plugins are what do the actual work of
transforming files at each step of the build process. The API of a plugin is pretty simple, all that’s required is
creating a class that extends the <a href="https://github.com/broccolijs/broccoli-plugin">broccoli-plugin</a> base class, and
implementing a <code>build()</code> method, that performs some work or returns a promise.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> Plugin <span class="hljs-keyword">from</span> <span class="hljs-string">'broccoli-plugin'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPlugin</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Plugin</span>
</span>{
  build() {
    <span class="hljs-comment">// A plugin can receive single or multiple inputs nodes/directories</span>
    <span class="hljs-comment">// The files are available in this.inputPaths[0]/this.inputPaths[1]...</span>
    <span class="hljs-comment">// You can do anything with these files that you can do in Node</span>
    <span class="hljs-comment">// The output of your plugin must write to this.outputPath</span>
  }
}
</code></pre>
<p>A broccoli-plugin has only one purpose, to transform the files from its <code>this.inputPaths</code> directories to its
<code>this.outputPath</code> directory when its <code>build()</code> function is invoked. Anything you can do in Node, you can do in
the <code>build()</code> method. A plugin can receive one or multiple inputs, and these are available in the <code>this.inputPaths</code>
array in the order they are provided.</p>
<p><code>this.inputPaths</code> contains paths to directories, that are the <code>outputPath</code> of previous plugins. Each <code>inputPath</code>
contains files that you can manipulate and write to <code>this.outputPath</code>. Broccoli will handle the state of these
directories and take responsibility for passing them between plugins.</p>
<p>There is a special case where a <code>string</code> is passed as an input to a plugin. When parsing your build pipeline,
Broccoli will automatically convert a string input into a
<a href="https://github.com/broccolijs/broccoli-source">source plugin</a>. This plugin basically connects its input directory
to its output directory, and also allows Broccoli to <code>watch</code> and be notified when files within the input
directory change and trigger a rebuild. You can also manually create an <code>unwatched</code> directory from a string by
using <a href="https://github.com/broccolijs/broccoli-source#new-unwatcheddirdirectorypath-options">UnwatchedDir</a>,
changes in this directory will not trigger a rebuild.</p>
<h3 id="trees">Trees <a class="header-anchor" href="#trees">⚭</a></h3>
<p>The build pipeline is a series of connected plugins, from one or more input directories to a single target directory.
Working from the target directory (the final output) back up to the source directories resembles a tree. Think of a
piece of Broccoli and you should have a mental model of what a build pipeline looks like.</p>
<div style="text-align: center">
<p><img src="/assets/logo/logo-small-fbddd31dd0d8a230a726d8c36e8b5b40.png" alt="broccoli tree"></p>
</div>
<p>Broccoli parses the result of the <code>export default</code> from the <code>Brocfile.js</code>, and traverses up all of the connected
nodes all the way to the source directories to produce this tree.</p>
<p>As Broccoli does this, it sets up the filesystem state for each plugin, creating an <code>outputPath</code> for each to write
to. Broccoli normalizes each plugin into what it calls <code>nodes</code>, that contain information about the inputs and
output of each item in the build pipeline.</p>
<p>You may often encounter the term “tree” when reading plugin READMEs or in tutorials, just remember a tree is a
connected set of plugins.</p>
<h2 id="building">Building <a class="header-anchor" href="#building">⚭</a></h2>
<p>When Broccoli starts up, the build file <code>Brocfile.js</code> file in the root of the project is parsed, from last
(target) plugin/node up to the source directories. As it does so, Broccoli handles wiring up all of the nodes’
inputs and outputs into a graph (from the end node up to the start nodes), creating temporary output directories
for each as it goes, linking inputs to outputs.</p>
<p>This graph of nodes is held in memory, and reused whenever a rebuild is triggered. When a <code>build</code> or <code>rebuild</code>
is triggered, Broccoli will invoke the <code>build()</code> method on each plugin in the order they’re defined in the
<code>Brocfile.js</code>, building one plugin at a time, and finally write the files from the final node into the
destination build directory.</p>
<p>Here’s an example:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> mergeTrees <span class="hljs-keyword">from</span> <span class="hljs-string">"broccoli-merge-trees"</span>; <span class="hljs-comment">// broccoli merge-trees plugin</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () =&gt; mergeTrees([<span class="hljs-string">"dir1"</span>, <span class="hljs-string">"dir2"</span>]);
</code></pre>
<p>This is a very simple <code>Brocfile.js</code> that merely merges the contents of <code>dir1</code> and <code>dir2</code> into the output
directory. The node graph would be represented as follows:</p>
<pre><code class="hljs">source plugin
               =====&gt; merge plugin
source plugin
------------------------
/dir1 =&gt; source <span class="hljs-keyword">node</span> <span class="hljs-title">1</span>
/dir2 =&gt; source <span class="hljs-keyword">node</span> <span class="hljs-title">2</span>
mergeTrees(
    'dir1', =&gt; source <span class="hljs-keyword">node</span><span class="hljs-title">, implicitly</span> created when using a <span class="hljs-keyword">string</span> as an input
    'dir2' =&gt; source <span class="hljs-keyword">node</span><span class="hljs-title">, implicitly</span> created when using a <span class="hljs-keyword">string</span> as an input
)
export default () =&gt; broccoli-merge-trees <span class="hljs-keyword">node</span> <span class="hljs-title">with</span> source nodes dir1 <span class="hljs-keyword">and</span> dir2 as inputs
</code></pre>
<p>The two input nodes reference two source directories, <code>dir1</code> and <code>dir2</code>.
Thus <code>export default</code> contains a node that references the two input nodes, and an output path that will contain the
contents of <code>dir1</code> and <code>dir2</code> when the <code>build</code> command is run.</p>
<h2 id="serving">Serving <a class="header-anchor" href="#serving">⚭</a></h2>
<p>One last thing. Broccoli comes with a built in development server that provides an HTTP server to host your assets
in development, and perform rebuilds when source directories (nodes) change.</p>
<p>The local HTTP server runs on <code>http://localhost:4200</code></p>
<p>Ok, that pretty much wraps up the basics, let’s continue on and learn how to setup a Broccoli build pipeline in the
<a href="/getting-started.html">Getting Started</a> guide.</p>
</div>
    </section>

    <footer>
    Found an error/typo on this page? <a href="https://github.com/broccolijs/broccolijs.github.io/edit/code/src/content/about.md">Why not propose a fix?</a>
</footer>

</body>

</html>